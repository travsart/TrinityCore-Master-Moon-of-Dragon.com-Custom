/*
 * Copyright (C) 2024 TrinityCore <https://www.trinitycore.org/>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 */

#include "PriestAI.h"
#include "HolySpecialization.h"
#include "DisciplineSpecialization.h"
#include "ShadowSpecialization.h"
#include "Player.h"
#include "Unit.h"
#include "SpellMgr.h"
#include "SpellInfo.h"
#include "Map.h"
#include "Group.h"
#include "Item.h"
#include "MotionMaster.h"
#include "Log.h"
#include "ObjectAccessor.h"
#include "WorldSession.h"
#include "GridNotifiers.h"
#include "GridNotifiersImpl.h"
#include "Cell.h"
#include "CellImpl.h"
#include "../CooldownManager.h"
#include <algorithm>
#include <chrono>

namespace Playerbot
{

// Talent IDs for specialization detection
enum PriestTalents
{
    // Holy talents
    TALENT_SPIRIT_OF_REDEMPTION = 20711,
    TALENT_CIRCLE_OF_HEALING = 34861,
    TALENT_GUARDIAN_SPIRIT = 47788,
    TALENT_LIGHTWELL = 724,
    TALENT_BLESSED_RECOVERY = 27811,
    TALENT_EMPOWERED_HEALING = 33158,

    // Discipline talents
    TALENT_POWER_INFUSION = 10060,
    TALENT_PAIN_SUPPRESSION = 33206,
    TALENT_PENANCE = 47540,
    TALENT_BORROWED_TIME = 52795,
    TALENT_SOUL_WARDING = 63574,
    TALENT_DIVINE_AEGIS = 47509,

    // Shadow talents
    TALENT_SHADOWFORM = 15473,
    TALENT_VAMPIRIC_EMBRACE = 15286,
    TALENT_VAMPIRIC_TOUCH = 34914,
    TALENT_DISPERSION = 47585,
    TALENT_SHADOW_WEAVING = 15257,
    TALENT_MISERY = 33191
};

// Combat constants
static const float OPTIMAL_HEALING_RANGE = 40.0f;
static const float OPTIMAL_DPS_RANGE = 30.0f;
static const float SAFE_DISTANCE = 20.0f;
static const uint32 DISPEL_COOLDOWN = 8000;
static const uint32 FEAR_WARD_COOLDOWN = 180000;
static const uint32 PSYCHIC_SCREAM_COOLDOWN = 30000;
static const uint32 INNER_FIRE_DURATION = 600000; // 10 minutes
static const float MANA_CONSERVATION_THRESHOLD = 0.3f;
static const float EMERGENCY_HEALTH_THRESHOLD = 0.25f;

PriestAI::PriestAI(Player* bot) : ClassAI(bot),
    _currentSpec(PriestSpec::HOLY),
    _manaSpent(0),
    _healingDone(0),
    _damageDealt(0),
    _playersHealed(0),
    _damagePrevented(0),
    _lastDispel(0),
    _lastFearWard(0),
    _lastPsychicScream(0),
    _lastInnerFire(0)
{
    InitializeSpecialization();

    TC_LOG_DEBUG("module.playerbot.ai", "PriestAI created for player {} with specialization {}",
                 bot ? bot->GetName() : "null",
                 _specialization ? _specialization->GetSpecializationName() : "none");
}

PriestAI::~PriestAI() = default;

void PriestAI::UpdateRotation(::Unit* target)
{
    if (!GetBot())
        return;

    // Check if we need to switch specialization
    PriestSpec newSpec = DetectCurrentSpecialization();
    if (newSpec != _currentSpec)
    {
        SwitchSpecialization(newSpec);
    }

    // Update shared priest mechanics
    UpdatePriestBuffs();
    UpdateDispelling();
    CheckForDebuffs();

    // Handle healing priorities first
    ::Unit* healTarget = GetBestHealTarget();
    if (healTarget && ShouldPrioritizeHealing(healTarget))
    {
        HealTarget(healTarget);
        RecordHealingDone(100, healTarget); // Simplified for now
        return;
    }

    // Delegate to specialization for main rotation
    if (_specialization)
    {
        _specialization->UpdateRotation(target);
    }
    else
    {
        DelegateToSpecialization(target);
    }

    // Track combat metrics
    if (GetBot()->IsInCombat())
    {
        _damageDealt += CalculateDamageDealt(target);
        _healingDone += CalculateHealingDone();
        _manaSpent += CalculateManaUsage();
    }
}

void PriestAI::UpdateBuffs()
{
    if (!GetBot())
        return;

    UpdatePriestBuffs();
    UpdateFortitudeBuffs();

    // Delegate to specialization for specific buffs
    if (_specialization)
    {
        _specialization->UpdateBuffs();
    }
}

void PriestAI::UpdateCooldowns(uint32 diff)
{
    if (!GetBot())
        return;

    // Update priest-specific cooldown tracking
    if (_cooldownManager)
        _cooldownManager->Update(diff);

    // Check for major cooldown availability
    // CheckMajorCooldowns(); // TODO: Implement when needed

    // Delegate to specialization
    if (_specialization)
    {
        _specialization->UpdateCooldowns(diff);
    }
}

bool PriestAI::CanUseAbility(uint32 spellId)
{
    if (!GetBot())
        return false;

    // Check basic requirements
    if (!IsSpellReady(spellId) || !HasEnoughResource(spellId))
        return false;

    // Check priest-specific conditions
    if (IsHealingSpell(spellId) && ShouldConserveMana())
        return false;

    // Delegate to specialization for additional checks
    if (_specialization)
    {
        return _specialization->CanUseAbility(spellId);
    }

    return true;
}

void PriestAI::OnCombatStart(::Unit* target)
{
    if (!GetBot() || !target)
        return;

    TC_LOG_DEBUG("module.playerbot.ai", "Priest {} entering combat with {}",
                 GetBot()->GetName(), target->GetName());

    // Apply pre-combat preparations
    CastPowerWordFortitude();
    CastInnerFire();

    // Apply initial shield on self if needed
    if (GetBot()->GetHealthPct() < 90.0f)
    {
        CastSpell(GetBot(), PriestSpells::POWER_WORD_SHIELD);
    }

    // Cast Fear Ward on tank if available
    if (Group* group = GetBot()->GetGroup())
    {
        if (Player* tank = FindGroupTank(group))
        {
            CastFearWard();
        }
    }

    // Delegate to specialization
    if (_specialization)
    {
        _specialization->OnCombatStart(target);
    }

    // Initialize combat tracking
    _combatTime = 0;
    _inCombat = true;
    _currentTarget = target;
}

void PriestAI::OnCombatEnd()
{
    if (!GetBot())
        return;

    TC_LOG_DEBUG("module.playerbot.ai", "Priest {} leaving combat. Metrics - Healing: {}, Damage: {}, Mana Used: {}, Players Healed: {}",
                 GetBot()->GetName(), _healingDone, _damageDealt, _manaSpent, _playersHealed);

    // Post-combat healing
    HealGroupMembers();

    // Reapply buffs if needed
    UpdatePriestBuffs();

    // Delegate to specialization
    if (_specialization)
    {
        _specialization->OnCombatEnd();
    }

    // Reset combat tracking
    _inCombat = false;
    _currentTarget = nullptr;

    // Log performance metrics
    AnalyzeHealingEfficiency();
}

bool PriestAI::HasEnoughResource(uint32 spellId)
{
    if (!GetBot())
        return false;

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId, DIFFICULTY_NONE);
    if (!spellInfo)
        return false;

    // Check mana cost
    auto powerCosts = spellInfo->CalcPowerCost(GetBot(), spellInfo->GetSchoolMask());
    for (auto const& cost : powerCosts)
    {
        if (cost.Power == POWER_MANA && GetBot()->GetPower(POWER_MANA) < int32(cost.Amount))
            return false;
    }

    // Check for mana conservation mode
    if (ShouldConserveMana() && !IsEmergencyHeal(spellId))
    {
        float manaPercent = GetManaPercent();
        if (manaPercent < MANA_CONSERVATION_THRESHOLD)
            return false;
    }

    // Delegate additional checks to specialization
    if (_specialization)
    {
        return _specialization->HasEnoughResource(spellId);
    }

    return true;
}

void PriestAI::ConsumeResource(uint32 spellId)
{
    if (!GetBot())
        return;

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId, DIFFICULTY_NONE);
    if (!spellInfo)
        return;

    // Track mana consumption
    auto powerCosts = spellInfo->CalcPowerCost(GetBot(), spellInfo->GetSchoolMask());
    for (auto const& cost : powerCosts)
    {
        if (cost.Power == POWER_MANA)
            _manaSpent += cost.Amount;
    }

    // Track specific spell usage
    if (IsHealingSpell(spellId))
    {
        _playersHealed++;
    }
    else if (IsDamageSpell(spellId))
    {
        _damageDealt += 100; // Simplified
    }

    // Delegate to specialization
    if (_specialization)
    {
        _specialization->ConsumeResource(spellId);
    }
}

Position PriestAI::GetOptimalPosition(::Unit* target)
{
    if (!GetBot() || !target)
        return Position();

    // Delegate to specialization for position preference
    if (_specialization)
    {
        return _specialization->GetOptimalPosition(target);
    }

    // Default positioning for priests - maintain range
    float optimalRange = GetOptimalRange(target);
    float angle = GetBot()->GetAbsoluteAngle(target);

    // Position behind and to the side for safety
    angle += M_PI / 4; // 45 degrees offset

    float x = target->GetPositionX() - optimalRange * std::cos(angle);
    float y = target->GetPositionY() - optimalRange * std::sin(angle);
    float z = target->GetPositionZ();

    return Position(x, y, z);
}

float PriestAI::GetOptimalRange(::Unit* target)
{
    if (!GetBot() || !target)
        return OPTIMAL_HEALING_RANGE;

    // Delegate to specialization for range preference
    if (_specialization)
    {
        return _specialization->GetOptimalRange(target);
    }

    // Default range based on spec
    switch (_currentSpec)
    {
        case PriestSpec::SHADOW:
            return OPTIMAL_DPS_RANGE;
        case PriestSpec::HOLY:
        case PriestSpec::DISCIPLINE:
        default:
            return OPTIMAL_HEALING_RANGE;
    }
}

void PriestAI::InitializeSpecialization()
{
    _currentSpec = DetectCurrentSpecialization();
    SwitchSpecialization(_currentSpec);
}

void PriestAI::UpdateSpecialization()
{
    PriestSpec newSpec = DetectCurrentSpecialization();
    if (newSpec != _currentSpec)
    {
        SwitchSpecialization(newSpec);
    }
}

PriestSpec PriestAI::DetectCurrentSpecialization()
{
    if (!GetBot())
        return PriestSpec::HOLY;

    // Check for key Shadow talents
    if (GetBot()->HasSpell(TALENT_SHADOWFORM) ||
        GetBot()->HasSpell(TALENT_VAMPIRIC_TOUCH) ||
        GetBot()->HasSpell(TALENT_DISPERSION))
    {
        return PriestSpec::SHADOW;
    }

    // Check for key Discipline talents
    if (GetBot()->HasSpell(TALENT_PENANCE) ||
        GetBot()->HasSpell(TALENT_PAIN_SUPPRESSION) ||
        GetBot()->HasSpell(TALENT_POWER_INFUSION))
    {
        return PriestSpec::DISCIPLINE;
    }

    // Check for key Holy talents
    if (GetBot()->HasSpell(TALENT_CIRCLE_OF_HEALING) ||
        GetBot()->HasSpell(TALENT_GUARDIAN_SPIRIT) ||
        GetBot()->HasSpell(TALENT_SPIRIT_OF_REDEMPTION))
    {
        return PriestSpec::HOLY;
    }

    // Default to Holy if no clear specialization
    return PriestSpec::HOLY;
}

void PriestAI::SwitchSpecialization(PriestSpec newSpec)
{
    if (_currentSpec == newSpec && _specialization)
        return;

    _currentSpec = newSpec;
    _specialization.reset();

    switch (newSpec)
    {
        case PriestSpec::HOLY:
            _specialization = std::make_unique<HolySpecialization>(GetBot());
            TC_LOG_DEBUG("module.playerbot.ai", "Priest {} switching to Holy specialization", GetBot()->GetName());
            break;
        case PriestSpec::DISCIPLINE:
            _specialization = std::make_unique<DisciplineSpecialization>(GetBot());
            TC_LOG_DEBUG("module.playerbot.ai", "Priest {} switching to Discipline specialization", GetBot()->GetName());
            break;
        case PriestSpec::SHADOW:
            _specialization = std::make_unique<ShadowSpecialization>(GetBot());
            TC_LOG_DEBUG("module.playerbot.ai", "Priest {} switching to Shadow specialization", GetBot()->GetName());
            break;
    }

    OptimizeForSpecialization();
}

void PriestAI::DelegateToSpecialization(::Unit* target)
{
    if (!_specialization || !target)
        return;

    _specialization->UpdateRotation(target);
}

void PriestAI::UpdatePriestBuffs()
{
    if (!GetBot())
        return;

    // Maintain Inner Fire
    if (!HasAura(PriestSpells::INNER_FIRE) || (getMSTime() - _lastInnerFire > INNER_FIRE_DURATION))
    {
        CastInnerFire();
    }

    // Maintain Power Word: Fortitude
    if (!HasAura(PriestSpells::POWER_WORD_FORTITUDE) && !HasAura(PriestSpells::PRAYER_OF_FORTITUDE))
    {
        CastPowerWordFortitude();
    }

    // Maintain Divine Spirit if available
    if (GetBot()->HasSpell(PriestSpells::DIVINE_SPIRIT) && !HasAura(PriestSpells::DIVINE_SPIRIT) && !HasAura(PriestSpells::PRAYER_OF_SPIRIT))
    {
        CastSpell(GetBot(), PriestSpells::DIVINE_SPIRIT);
    }

    // Shadow Protection for shadow damage heavy encounters
    if (ShouldUseShadowProtection() && !HasAura(PriestSpells::SHADOW_PROTECTION))
    {
        UseShadowProtection();
    }
}

void PriestAI::CastInnerFire()
{
    if (!GetBot() || !IsSpellReady(PriestSpells::INNER_FIRE))
        return;

    if (CastSpell(GetBot(), PriestSpells::INNER_FIRE))
    {
        _lastInnerFire = getMSTime();
    }
}

void PriestAI::UpdateFortitudeBuffs()
{
    if (!GetBot())
        return;

    // Check group members for fortitude
    if (Group* group = GetBot()->GetGroup())
    {
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (!player->HasAura(PriestSpells::POWER_WORD_FORTITUDE) && !player->HasAura(PriestSpells::PRAYER_OF_FORTITUDE))
                {
                    // Use Prayer of Fortitude if we have it and multiple people need it
                    if (GetBot()->HasSpell(PriestSpells::PRAYER_OF_FORTITUDE) && CountUnbuffedGroupMembers() >= 3)
                    {
                        CastSpell(PriestSpells::PRAYER_OF_FORTITUDE);
                        return;
                    }
                    else
                    {
                        CastSpell(player, PriestSpells::POWER_WORD_FORTITUDE);
                        return;
                    }
                }
            }
        }
    }
}

void PriestAI::CastPowerWordFortitude()
{
    if (!GetBot() || !IsSpellReady(PriestSpells::POWER_WORD_FORTITUDE))
        return;

    CastSpell(GetBot(), PriestSpells::POWER_WORD_FORTITUDE);
}

bool PriestAI::HasEnoughMana(uint32 amount)
{
    return GetBot() && GetBot()->GetPower(POWER_MANA) >= int32(amount);
}

uint32 PriestAI::GetMana()
{
    return GetBot() ? GetBot()->GetPower(POWER_MANA) : 0;
}

uint32 PriestAI::GetMaxMana()
{
    return GetBot() ? GetBot()->GetMaxPower(POWER_MANA) : 0;
}

float PriestAI::GetManaPercent()
{
    uint32 maxMana = GetMaxMana();
    return maxMana > 0 ? (float(GetMana()) / float(maxMana) * 100.0f) : 0.0f;
}

void PriestAI::OptimizeManaUsage()
{
    if (!GetBot())
        return;

    float manaPercent = GetManaPercent();

    // Use mana regeneration abilities
    if (manaPercent < 20.0f)
    {
        UseManaRegeneration();
    }

    // Use Shadowfiend if Shadow spec and low on mana
    if (_currentSpec == PriestSpec::SHADOW && manaPercent < 30.0f)
    {
        if (IsSpellReady(34433)) // Shadowfiend
        {
            CastSpell(_currentTarget, 34433);
        }
    }
}

bool PriestAI::ShouldConserveMana()
{
    return GetManaPercent() < MANA_CONSERVATION_THRESHOLD * 100.0f;
}

void PriestAI::UseManaRegeneration()
{
    if (!GetBot())
        return;

    // Use Hymn of Hope if available
    if (IsSpellReady(PriestSpells::HYMN_OF_HOPE))
    {
        CastHymnOfHope();
    }

    // Use mana potion if available
    // This would need item handling implementation
}

void PriestAI::CastHymnOfHope()
{
    if (!GetBot() || !IsSpellReady(PriestSpells::HYMN_OF_HOPE))
        return;

    // Channel Hymn of Hope
    CastSpell(PriestSpells::HYMN_OF_HOPE);
}

void PriestAI::UseDefensiveAbilities()
{
    if (!GetBot() || !IsInDanger())
        return;

    // Use Fade to reduce threat
    if (HasTooMuchThreat())
    {
        CastFade();
    }

    // Use Psychic Scream if enemies are too close
    if (GetNearestEnemy(8.0f))
    {
        CastPsychicScream();
    }

    // Use Desperate Prayer if health is low
    if (GetBot()->GetHealthPct() < 30.0f && IsSpellReady(48173)) // Desperate Prayer
    {
        CastSpell(GetBot(), 48173);
    }
}

void PriestAI::CastPsychicScream()
{
    if (!GetBot() || !IsSpellReady(PriestSpells::PSYCHIC_SCREAM))
        return;

    if (getMSTime() - _lastPsychicScream < PSYCHIC_SCREAM_COOLDOWN)
        return;

    if (CastSpell(PriestSpells::PSYCHIC_SCREAM))
    {
        _lastPsychicScream = getMSTime();
    }
}

void PriestAI::CastFade()
{
    if (!GetBot() || !IsSpellReady(PriestSpells::FADE))
        return;

    CastSpell(PriestSpells::FADE);
}

void PriestAI::CastDispelMagic()
{
    if (!GetBot())
        return;

    ::Unit* target = GetBestDispelTarget();
    if (target && IsSpellReady(PriestSpells::DISPEL_MAGIC))
    {
        if (getMSTime() - _lastDispel > DISPEL_COOLDOWN)
        {
            if (CastSpell(target, PriestSpells::DISPEL_MAGIC))
            {
                _lastDispel = getMSTime();
            }
        }
    }
}

void PriestAI::CastFearWard()
{
    if (!GetBot() || !IsSpellReady(PriestSpells::FEAR_WARD))
        return;

    if (getMSTime() - _lastFearWard < FEAR_WARD_COOLDOWN)
        return;

    // Find best target for Fear Ward
    ::Unit* target = nullptr;
    if (Group* group = GetBot()->GetGroup())
    {
        target = FindGroupTank(group);
    }

    if (!target)
        target = GetBot();

    if (CastSpell(target, PriestSpells::FEAR_WARD))
    {
        _lastFearWard = getMSTime();
    }
}

void PriestAI::UseShadowProtection()
{
    if (!GetBot())
        return;

    // Use Prayer of Shadow Protection if available for group
    if (GetBot()->HasSpell(PriestSpells::PRAYER_OF_SHADOW_PROTECTION) && GetBot()->GetGroup())
    {
        CastSpell(PriestSpells::PRAYER_OF_SHADOW_PROTECTION);
    }
    else if (IsSpellReady(PriestSpells::SHADOW_PROTECTION))
    {
        CastSpell(GetBot(), PriestSpells::SHADOW_PROTECTION);
    }
}

void PriestAI::UseCrowdControl(::Unit* target)
{
    if (!GetBot() || !target)
        return;

    // Use Mind Control on humanoids
    if (target->GetCreatureType() == CREATURE_TYPE_HUMANOID)
    {
        CastMindControl(target);
    }
    // Use Shackle Undead on undead
    else if (target->GetCreatureType() == CREATURE_TYPE_UNDEAD)
    {
        CastShackleUndead(target);
    }
    // Use Silence on casters (if Shadow spec)
    else if (target->GetPowerType() == POWER_MANA && _currentSpec == PriestSpec::SHADOW)
    {
        CastSilence(target);
    }
}

void PriestAI::CastMindControl(::Unit* target)
{
    if (!GetBot() || !target || !IsSpellReady(PriestSpells::MIND_CONTROL))
        return;

    // Don't mind control if we already have one
    if (!_mindControlTargets.empty())
        return;

    if (CastSpell(target, PriestSpells::MIND_CONTROL))
    {
        _mindControlTargets[target->GetGUID()] = getMSTime();
    }
}

void PriestAI::CastShackleUndead(::Unit* target)
{
    if (!GetBot() || !target || !IsSpellReady(PriestSpells::SHACKLE_UNDEAD))
        return;

    CastSpell(target, PriestSpells::SHACKLE_UNDEAD);
}

void PriestAI::CastSilence(::Unit* target)
{
    if (!GetBot() || !target || !IsSpellReady(15487)) // Silence
        return;

    CastSpell(target, 15487);
}

void PriestAI::UpdatePriestPositioning()
{
    if (!GetBot() || !_currentTarget)
        return;

    // Check if we need to reposition
    if (!IsAtOptimalHealingRange(nullptr))
    {
        MaintainHealingPosition();
    }

    // Move away from danger
    if (IsInDanger())
    {
        FindSafePosition();
    }
}

bool PriestAI::IsAtOptimalHealingRange(::Unit* target)
{
    if (!GetBot())
        return false;

    if (!target)
    {
        // Check range to group members
        if (Group* group = GetBot()->GetGroup())
        {
            for (Group::MemberSlot const& member : group->GetMemberSlots())
            {
                if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
                {
                    if (GetBot()->GetDistance(player) > OPTIMAL_HEALING_RANGE)
                        return false;
                }
            }
        }
        return true;
    }

    return GetBot()->GetDistance(target) <= OPTIMAL_HEALING_RANGE;
}

void PriestAI::MaintainHealingPosition()
{
    if (!GetBot())
        return;

    // Find center of group
    if (Group* group = GetBot()->GetGroup())
    {
        float avgX = 0, avgY = 0, avgZ = 0;
        uint32 count = 0;

        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                avgX += player->GetPositionX();
                avgY += player->GetPositionY();
                avgZ += player->GetPositionZ();
                count++;
            }
        }

        if (count > 0)
        {
            avgX /= count;
            avgY /= count;
            avgZ /= count;

            // Move towards group center but maintain safe distance from enemies
            Position centerPos(avgX, avgY, avgZ);
            MoveToTarget(nullptr, SAFE_DISTANCE);
        }
    }
}

bool PriestAI::IsInDanger()
{
    if (!GetBot())
        return false;

    // Check if we have aggro
    if (HasTooMuchThreat())
        return true;

    // Check if enemies are too close
    if (GetNearestEnemy(10.0f))
        return true;

    // Check if health is low
    if (GetBot()->GetHealthPct() < 30.0f)
        return true;

    return false;
}

void PriestAI::FindSafePosition()
{
    if (!GetBot())
        return;

    // Move away from nearest enemy
    if (::Unit* enemy = GetNearestEnemy(20.0f))
    {
        float angle = GetBot()->GetAbsoluteAngle(enemy) + M_PI; // Opposite direction
        float distance = SAFE_DISTANCE;

        float x = GetBot()->GetPositionX() + distance * std::cos(angle);
        float y = GetBot()->GetPositionY() + distance * std::sin(angle);
        float z = GetBot()->GetPositionZ();

        GetBot()->GetMotionMaster()->MovePoint(0, x, y, z);
    }
}

::Unit* PriestAI::GetBestHealTarget()
{
    if (!GetBot())
        return nullptr;

    ::Unit* lowestHealthTarget = nullptr;
    float lowestHealthPct = 100.0f;

    // Check self first
    if (GetBot()->GetHealthPct() < EMERGENCY_HEALTH_THRESHOLD * 100.0f)
        return GetBot();

    // Check group members
    if (Group* group = GetBot()->GetGroup())
    {
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (!player->IsAlive())
                    continue;

                float healthPct = player->GetHealthPct();
                if (healthPct < lowestHealthPct && GetBot()->GetDistance(player) <= OPTIMAL_HEALING_RANGE)
                {
                    lowestHealthPct = healthPct;
                    lowestHealthTarget = player;
                }
            }
        }
    }

    // Return target if they need healing
    if (lowestHealthTarget && lowestHealthPct < 80.0f)
        return lowestHealthTarget;

    return nullptr;
}

::Unit* PriestAI::GetBestDispelTarget()
{
    if (!GetBot())
        return nullptr;

    // Priority: Self > Tank > Healer > DPS

    // Check self for dispellable debuffs
    if (HasDispellableDebuff(GetBot()))
        return GetBot();

    // Check group members
    if (Group* group = GetBot()->GetGroup())
    {
        // First pass - tanks
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (IsTank(player) && HasDispellableDebuff(player))
                    return player;
            }
        }

        // Second pass - healers
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (IsHealer(player) && HasDispellableDebuff(player))
                    return player;
            }
        }

        // Third pass - any member
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (HasDispellableDebuff(player))
                    return player;
            }
        }
    }

    return nullptr;
}

::Unit* PriestAI::GetBestMindControlTarget()
{
    if (!GetBot() || !_mindControlTargets.empty())
        return nullptr;

    // Look for humanoid enemies
    std::list<::Unit*> targets;
    Trinity::AnyUnfriendlyUnitInObjectRangeCheck checker(GetBot(), GetBot(), 30.0f);
    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(GetBot(), targets, checker);
    Cell::VisitAllObjects(GetBot(), searcher, 30.0f);

    for (::Unit* target : targets)
    {
        if (target->GetCreatureType() == CREATURE_TYPE_HUMANOID &&
            !target->HasAura(PriestSpells::MIND_CONTROL) &&
            target->GetLevel() <= GetBot()->GetLevel() + 2)
        {
            return target;
        }
    }

    return nullptr;
}

::Unit* PriestAI::GetLowestHealthAlly()
{
    return GetLowestHealthAlly(OPTIMAL_HEALING_RANGE);
}

::Unit* PriestAI::GetHighestPriorityPatient()
{
    if (!GetBot())
        return nullptr;

    struct PatientInfo
    {
        ::Unit* unit;
        float priority;
    };

    std::vector<PatientInfo> patients;

    // Calculate priority for each potential patient
    if (Group* group = GetBot()->GetGroup())
    {
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(GetBot()->GetMap(), member.guid))
            {
                if (!player->IsAlive() || player->GetHealthPct() >= 95.0f)
                    continue;

                float priority = 100.0f - player->GetHealthPct();

                // Increase priority for tanks (Warriors, Paladins, Death Knights)
                uint8 playerClass = player->getClass();
                if (playerClass == CLASS_WARRIOR || playerClass == CLASS_PALADIN || playerClass == CLASS_DEATH_KNIGHT)
                    priority *= 1.5f;

                // Increase priority for healers (Priests, Druids, Shamans, Paladins)
                if (playerClass == CLASS_PRIEST || playerClass == CLASS_DRUID || playerClass == CLASS_SHAMAN)
                    priority *= 1.3f;

                // Increase priority if in combat
                if (player->IsInCombat())
                    priority *= 1.2f;

                patients.push_back({player, priority});
            }
        }
    }

    // Sort by priority
    std::sort(patients.begin(), patients.end(),
              [](const PatientInfo& a, const PatientInfo& b) { return a.priority > b.priority; });

    return patients.empty() ? nullptr : patients.front().unit;
}

void PriestAI::ProvideUtilitySupport()
{
    if (!GetBot())
        return;

    // Levitate falling allies
    if (Group* group = GetBot()->GetGroup())
    {
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (player->IsFalling() && !player->HasAura(PriestSpells::LEVITATE))
                {
                    CastSpell(player, PriestSpells::LEVITATE);
                    return;
                }
            }
        }
    }
}

void PriestAI::UpdateDispelling()
{
    if (!GetBot() || getMSTime() - _lastDispel < DISPEL_COOLDOWN)
        return;

    ::Unit* dispelTarget = GetBestDispelTarget();
    if (dispelTarget)
    {
        CastDispelMagic();
    }
}

void PriestAI::CheckForDebuffs()
{
    if (!GetBot())
        return;

    // Check for diseases to cure
    if (GetBot()->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && IsSpellReady(PriestSpells::CURE_DISEASE))
    {
        CastSpell(GetBot(), PriestSpells::CURE_DISEASE);
    }

    // Check group members for debuffs
    if (Group* group = GetBot()->GetGroup())
    {
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (player->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && IsSpellReady(PriestSpells::CURE_DISEASE))
                {
                    CastSpell(player, PriestSpells::CURE_DISEASE);
                    return;
                }
            }
        }
    }
}

void PriestAI::AssistGroupMembers()
{
    if (!GetBot())
        return;

    // Provide utility support
    ProvideUtilitySupport();

    // Update dispelling
    UpdateDispelling();
}

void PriestAI::AdaptToGroupRole()
{
    if (!GetBot())
        return;

    // Check group composition
    if (Group* group = GetBot()->GetGroup())
    {
        uint32 healerCount = 0;
        uint32 dpsCount = 0;

        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (IsHealer(player))
                    healerCount++;
                else
                    dpsCount++;
            }
        }

        // Adapt role based on group needs
        if (healerCount == 1 && _currentSpec != PriestSpec::SHADOW)
        {
            // We're the only healer, focus on healing
            SwitchToHealingRole();
        }
        else if (healerCount >= 2 && _currentSpec == PriestSpec::SHADOW)
        {
            // Enough healers, can DPS
            SwitchToDamageRole();
        }
    }
}

void PriestAI::SwitchToHealingRole()
{
    if (!GetBot())
        return;

    // Prioritize healing abilities
    TC_LOG_DEBUG("module.playerbot.ai", "Priest {} switching to healing role", GetBot()->GetName());
}

void PriestAI::SwitchToDamageRole()
{
    if (!GetBot())
        return;

    // Prioritize damage abilities
    TC_LOG_DEBUG("module.playerbot.ai", "Priest {} switching to damage role", GetBot()->GetName());
}

void PriestAI::DetermineOptimalRole()
{
    AdaptToGroupRole();
}

void PriestAI::ManageHolyPower()
{
    // Holy-specific mechanics
    if (_currentSpec != PriestSpec::HOLY)
        return;

    // Manage Serendipity stacks for faster heals
    ManageSerendipity();

    // Update Circle of Healing usage
    UpdateCircleOfHealing();
}

void PriestAI::UpdateCircleOfHealing()
{
    if (!GetBot() || !IsSpellReady(PriestSpells::CIRCLE_OF_HEALING))
        return;

    // Count injured group members
    uint32 injuredCount = 0;
    if (Group* group = GetBot()->GetGroup())
    {
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (player->GetHealthPct() < 80.0f)
                    injuredCount++;
            }
        }
    }

    // Use Circle of Healing if 3+ injured
    if (injuredCount >= 3)
    {
        CastSpell(PriestSpells::CIRCLE_OF_HEALING);
    }
}

void PriestAI::ManageSerendipity()
{
    // Track and optimize Serendipity buff usage
    if (!GetBot())
        return;

    uint32 serendipityStacks = GetAuraStacks(63733, GetBot()); // Serendipity

    // Use faster Greater Heal or Prayer of Healing at 3 stacks
    if (serendipityStacks >= 3)
    {
        ::Unit* healTarget = GetHighestPriorityPatient();
        if (healTarget && healTarget->GetHealthPct() < 50.0f)
        {
            CastSpell(healTarget, PriestSpells::GREATER_HEAL);
        }
    }
}

void PriestAI::ManageDisciplineMechanics()
{
    // Discipline-specific mechanics
    if (_currentSpec != PriestSpec::DISCIPLINE)
        return;

    UpdateBorrowedTime();
    ManageGrace();
}

void PriestAI::UpdateBorrowedTime()
{
    // Manage Borrowed Time buff for haste after shield
    if (!GetBot())
        return;

    // Cast Power Word: Shield to trigger Borrowed Time
    ::Unit* target = GetHighestPriorityPatient();
    if (target && !target->HasAura(PriestSpells::POWER_WORD_SHIELD) && IsSpellReady(PriestSpells::POWER_WORD_SHIELD))
    {
        CastSpell(target, PriestSpells::POWER_WORD_SHIELD);
    }
}

void PriestAI::ManageGrace()
{
    // Manage Grace buff stacking on healing targets
    if (!GetBot())
        return;

    // Grace stacks from Flash Heal, Greater Heal, and Penance
    ::Unit* target = GetHighestPriorityPatient();
    if (target)
    {
        uint32 graceStacks = GetAuraStacks(47509, target); // Grace

        // Maintain Grace stacks on tank
        if (IsTank(target) && graceStacks < 3)
        {
            CastSpell(target, PriestSpells::FLASH_HEAL);
        }
    }
}

void PriestAI::ManageShadowMechanics()
{
    // Shadow-specific mechanics
    if (_currentSpec != PriestSpec::SHADOW)
        return;

    UpdateShadowWeaving();
    ManageVampiricEmbrace();
}

void PriestAI::UpdateShadowWeaving()
{
    // Manage Shadow Weaving debuff stacking
    if (!GetBot() || !_currentTarget)
        return;

    uint32 shadowWeavingStacks = GetAuraStacks(15258, _currentTarget); // Shadow Weaving

    // Maintain 5 stacks of Shadow Weaving
    if (shadowWeavingStacks < 5)
    {
        CastSpell(_currentTarget, PriestSpells::MIND_BLAST);
    }
}

void PriestAI::ManageVampiricEmbrace()
{
    // Manage Vampiric Embrace for group healing
    if (!GetBot() || !IsSpellReady(PriestSpells::VAMPIRIC_EMBRACE))
        return;

    // Activate Vampiric Embrace when group needs healing
    if (Group* group = GetBot()->GetGroup())
    {
        uint32 injuredCount = 0;
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (player->GetHealthPct() < 70.0f)
                    injuredCount++;
            }
        }

        if (injuredCount >= 2 && !HasAura(PriestSpells::VAMPIRIC_EMBRACE))
        {
            CastSpell(PriestSpells::VAMPIRIC_EMBRACE);
        }
    }
}

void PriestAI::ManageThreat()
{
    if (!GetBot())
        return;

    if (HasTooMuchThreat())
    {
        ReduceThreat();
    }
}

bool PriestAI::HasTooMuchThreat()
{
    if (!GetBot() || !_currentTarget)
        return false;

    // Check if we have aggro
    return _currentTarget->GetVictim() == GetBot();
}

void PriestAI::ReduceThreat()
{
    UseFade();
}

void PriestAI::UseFade()
{
    CastFade();
}

void PriestAI::RecordHealingDone(uint32 amount, ::Unit* target)
{
    _healingDone += amount;
    if (target && target->IsPlayer())
        _playersHealed++;
}

void PriestAI::RecordDamageDone(uint32 amount, ::Unit* target)
{
    _damageDealt += amount;
}

void PriestAI::AnalyzeHealingEfficiency()
{
    if (!GetBot() || _healingDone == 0 || _manaSpent == 0)
        return;

    float efficiency = float(_healingDone) / float(_manaSpent);

    TC_LOG_DEBUG("module.playerbot.ai", "Priest {} healing efficiency: {:.2f} healing per mana",
                 GetBot()->GetName(), efficiency);
}

void PriestAI::OptimizeHealingRotation()
{
    // Analyze and optimize healing spell usage
    AnalyzeHealingEfficiency();
}

bool PriestAI::IsHealingSpell(uint32 spellId)
{
    switch (spellId)
    {
                case PriestSpells::HEAL:
                case PriestSpells::GREATER_HEAL:
                case PriestSpells::FLASH_HEAL:
                case PriestSpells::RENEW:
                case PriestSpells::PRAYER_OF_HEALING:
                case PriestSpells::CIRCLE_OF_HEALING:
                case PriestSpells::BINDING_HEAL:
                case PriestSpells::GUARDIAN_SPIRIT:
                case PriestSpells::PENANCE:
            return true;
        default:
            return false;
    }
}

bool PriestAI::IsDamageSpell(uint32 spellId)
{
    switch (spellId)
    {
                case PriestSpells::SHADOW_WORD_PAIN:
                case PriestSpells::MIND_BLAST:
                case PriestSpells::MIND_FLAY:
                case PriestSpells::VAMPIRIC_TOUCH:
                case PriestSpells::DEVOURING_PLAGUE:
                case PriestSpells::SHADOW_WORD_DEATH:
            return true;
        default:
            return false;
    }
}

uint32 PriestAI::GetSpellHealAmount(uint32 spellId)
{
    // Simplified heal amount calculation
    // In real implementation, this would calculate based on spell power, talents, etc.
    switch (spellId)
    {
                case PriestSpells::FLASH_HEAL:
            return 2000;
                case PriestSpells::GREATER_HEAL:
            return 4000;
                case PriestSpells::HEAL:
            return 3000;
        default:
            return 1000;
    }
}

uint32 PriestAI::GetHealOverTimeRemaining(::Unit* target, uint32 spellId)
{
    if (!target)
        return 0;

    // Check remaining HoT duration
    if (Aura* aura = target->GetAura(spellId))
    {
        return aura->GetDuration();
    }

    return 0;
}

bool PriestAI::TargetHasHoT(::Unit* target, uint32 spellId)
{
    return target && target->HasAura(spellId);
}

PriestSpec PriestAI::DetectSpecialization()
{
    return DetectCurrentSpecialization();
}

void PriestAI::OptimizeForSpecialization()
{
    if (!GetBot())
        return;

    // Optimize action bars and priorities based on spec
    switch (_currentSpec)
    {
        case PriestSpec::HOLY:
            TC_LOG_DEBUG("module.playerbot.ai", "Optimizing {} for Holy healing", GetBot()->GetName());
            break;
        case PriestSpec::DISCIPLINE:
            TC_LOG_DEBUG("module.playerbot.ai", "Optimizing {} for Discipline support", GetBot()->GetName());
            break;
        case PriestSpec::SHADOW:
            TC_LOG_DEBUG("module.playerbot.ai", "Optimizing {} for Shadow damage", GetBot()->GetName());
            break;
    }
}

bool PriestAI::HasTalent(uint32 talentId)
{
    return GetBot() && GetBot()->HasSpell(talentId);
}

// Helper methods implementation
bool PriestAI::ShouldPrioritizeHealing(::Unit* target)
{
    if (!target)
        return false;

    // Always prioritize emergency healing
    if (target->GetHealthPct() < EMERGENCY_HEALTH_THRESHOLD * 100.0f)
        return true;

    // Prioritize tank healing
    if (IsTank(target) && target->GetHealthPct() < 50.0f)
        return true;

    // Prioritize self-healing if in danger
    if (target == GetBot() && GetBot()->GetHealthPct() < 40.0f)
        return true;

    return false;
}

void PriestAI::HealTarget(::Unit* target)
{
    if (!GetBot() || !target)
        return;

    float healthPct = target->GetHealthPct();

    // Emergency healing
    if (healthPct < 30.0f)
    {
        if (IsSpellReady(PriestSpells::FLASH_HEAL))
            CastSpell(target, PriestSpells::FLASH_HEAL);
        else if (IsSpellReady(PriestSpells::BINDING_HEAL) && GetBot()->GetHealthPct() < 70.0f)
            CastSpell(target, PriestSpells::BINDING_HEAL);
    }
    // Moderate healing
    else if (healthPct < 60.0f)
    {
        if (!TargetHasHoT(target, PriestSpells::RENEW))
            CastSpell(target, PriestSpells::RENEW);

        if (IsSpellReady(PriestSpells::GREATER_HEAL))
            CastSpell(target, PriestSpells::GREATER_HEAL);
    }
    // Maintenance healing
    else if (healthPct < 80.0f)
    {
        if (!TargetHasHoT(target, PriestSpells::RENEW))
            CastSpell(target, PriestSpells::RENEW);
        else if (IsSpellReady(PriestSpells::HEAL))
            CastSpell(target, PriestSpells::HEAL);
    }
}

void PriestAI::HealGroupMembers()
{
    if (!GetBot())
        return;

    if (Group* group = GetBot()->GetGroup())
    {
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (player->IsAlive() && player->GetHealthPct() < 90.0f)
                {
                    HealTarget(player);
                }
            }
        }
    }
}

bool PriestAI::IsEmergencyHeal(uint32 spellId)
{
    return spellId == PriestSpells::FLASH_HEAL || spellId == PriestSpells::BINDING_HEAL || spellId == PriestSpells::GUARDIAN_SPIRIT;
}

bool PriestAI::ShouldUseShadowProtection()
{
    // Check if we're facing shadow damage enemies
    // Simplified - would check actual enemy abilities in real implementation
    return false;
}

uint32 PriestAI::CountUnbuffedGroupMembers()
{
    if (!GetBot())
        return 0;

    uint32 count = 0;
    if (Group* group = GetBot()->GetGroup())
    {
        for (Group::MemberSlot const& member : group->GetMemberSlots())
        {
            if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
            {
                if (!player->HasAura(PriestSpells::POWER_WORD_FORTITUDE) && !player->HasAura(PriestSpells::PRAYER_OF_FORTITUDE))
                    count++;
            }
        }
    }
    return count;
}

// Helper method implementations
void PriestAI::CheckMajorCooldowns()
{
    if (!GetBot())
        return;

    // Check if major cooldowns are available
    // Guardian Spirit, Pain Suppression, Power Infusion, etc.
}

bool PriestAI::IsTank(::Unit* unit)
{
    if (!unit || !unit->IsPlayer())
        return false;

    Player* player = unit->ToPlayer();

    // Simple tank detection
    return player->GetClass() == CLASS_WARRIOR ||
           player->GetClass() == CLASS_PALADIN ||
           player->GetClass() == CLASS_DEATH_KNIGHT;
}

bool PriestAI::IsHealer(::Unit* unit)
{
    if (!unit || !unit->IsPlayer())
        return false;

    Player* player = unit->ToPlayer();

    // Simple healer detection
    return player->GetClass() == CLASS_PRIEST ||
           player->GetClass() == CLASS_PALADIN ||
           player->GetClass() == CLASS_SHAMAN ||
           player->GetClass() == CLASS_DRUID;
}

bool PriestAI::HasDispellableDebuff(::Unit* unit)
{
    if (!unit)
        return false;

    // Check for magic debuffs that can be dispelled
    return unit->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) ||
           unit->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) ||
           unit->HasAuraType(SPELL_AURA_MOD_ROOT);
}

Player* PriestAI::FindGroupTank(Group* group)
{
    if (!group)
        return nullptr;

    Player* tank = nullptr;
    uint32 highestHealth = 0;

    for (Group::MemberSlot const& member : group->GetMemberSlots())
    {
        if (Player* player = ObjectAccessor::GetPlayer(*GetBot(), member.guid))
        {
            if (IsTank(player) && player->GetMaxHealth() > highestHealth)
            {
                highestHealth = player->GetMaxHealth();
                tank = player;
            }
        }
    }

    return tank;
}

uint32 PriestAI::CalculateDamageDealt(::Unit* target) const
{
    // Simplified damage calculation
    return _currentSpec == PriestSpec::SHADOW ? 200 : 50;
}

uint32 PriestAI::CalculateHealingDone() const
{
    // Simplified healing calculation
    return _currentSpec != PriestSpec::SHADOW ? 300 : 100;
}

uint32 PriestAI::CalculateManaUsage() const
{
    // Simplified mana usage calculation
    return 100;
}

// PriestHealCalculator implementation
std::unordered_map<uint32, uint32> PriestHealCalculator::_baseHealCache;
std::unordered_map<uint32, float> PriestHealCalculator::_efficiencyCache;
std::mutex PriestHealCalculator::_cacheMutex;

uint32 PriestHealCalculator::CalculateHealAmount(uint32 spellId, Player* caster, ::Unit* target)
{
    if (!caster || !target)
        return 0;

    // Simplified heal calculation
    uint32 baseHeal = 1000;

    switch (spellId)
    {
        case 2061: // Flash Heal
            baseHeal = 2000;
            break;
        case 2060: // Greater Heal
            baseHeal = 4000;
            break;
        case 2050: // Heal
            baseHeal = 3000;
            break;
        case 139: // Renew
            baseHeal = 1500;
            break;
        case 596: // Prayer of Healing
            baseHeal = 2500;
            break;
    }

    // Apply spell power scaling (simplified)
    float spellPower = caster->GetTotalAuraModValue(UNIT_MOD_DAMAGE_DONE);
    baseHeal += uint32(spellPower * 0.8f);

    return baseHeal;
}

uint32 PriestHealCalculator::CalculateHealOverTime(uint32 spellId, Player* caster)
{
    if (!caster)
        return 0;

    // Simplified HoT calculation
    switch (spellId)
    {
        case 139: // Renew
            return 3000; // Total over duration
        default:
            return 0;
    }
}

float PriestHealCalculator::CalculateHealEfficiency(uint32 spellId, Player* caster)
{
    if (!caster)
        return 0.0f;

    std::lock_guard<std::mutex> lock(_cacheMutex);

    auto it = _efficiencyCache.find(spellId);
    if (it != _efficiencyCache.end())
        return it->second;

    // Calculate heal per mana
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId, DIFFICULTY_NONE);
    if (!spellInfo)
        return 0.0f;

    auto powerCosts = spellInfo->CalcPowerCost(caster, spellInfo->GetSchoolMask());
    uint32 manaCost = 0;
    for (auto const& cost : powerCosts)
    {
        if (cost.Power == POWER_MANA)
            manaCost = cost.Amount;
    }

    if (manaCost == 0)
        return 999.0f; // Free spell

    uint32 healAmount = CalculateHealAmount(spellId, caster, caster);
    float efficiency = float(healAmount) / float(manaCost);

    _efficiencyCache[spellId] = efficiency;
    return efficiency;
}

float PriestHealCalculator::CalculateHealPerMana(uint32 spellId, Player* caster)
{
    return CalculateHealEfficiency(spellId, caster);
}

uint32 PriestHealCalculator::GetOptimalHealForSituation(Player* caster, ::Unit* target, uint32 missingHealth)
{
    if (!caster || !target)
        return 0;

    // Choose heal based on missing health
    if (missingHealth > 4000)
        return 2060; // Greater Heal
    else if (missingHealth > 2000)
        return 2050; // Heal
    else if (missingHealth > 1000)
        return 2061; // Flash Heal
    else
        return 139; // Renew
}

bool PriestHealCalculator::ShouldUseDirectHeal(Player* caster, ::Unit* target)
{
    if (!target)
        return false;

    return target->GetHealthPct() < 70.0f;
}

bool PriestHealCalculator::ShouldUseHealOverTime(Player* caster, ::Unit* target)
{
    if (!target)
        return false;

    return target->GetHealthPct() > 70.0f && !target->HasAura(139); // Renew
}

bool PriestHealCalculator::ShouldUseGroupHeal(Player* caster, const std::vector<::Unit*>& targets)
{
    if (targets.size() < 3)
        return false;

    uint32 injuredCount = 0;
    for (::Unit* target : targets)
    {
        if (target && target->GetHealthPct() < 80.0f)
            injuredCount++;
    }

    return injuredCount >= 3;
}

float PriestHealCalculator::CalculateHealThreat(uint32 healAmount, Player* caster)
{
    // Healing generates 0.5 threat per point healed
    return float(healAmount) * 0.5f;
}

bool PriestHealCalculator::WillOverheal(uint32 spellId, Player* caster, ::Unit* target)
{
    if (!caster || !target)
        return false;

    uint32 healAmount = CalculateHealAmount(spellId, caster, target);
    uint32 missingHealth = target->GetMaxHealth() - target->GetHealth();

    return healAmount > missingHealth * 1.1f; // 10% overheal threshold
}

void PriestHealCalculator::CacheHealData(uint32 spellId)
{
    // Pre-cache heal data for performance
    std::lock_guard<std::mutex> lock(_cacheMutex);

    if (_baseHealCache.find(spellId) == _baseHealCache.end())
    {
        // Cache base heal values
        switch (spellId)
        {
            case 2061: // Flash Heal
                _baseHealCache[spellId] = 2000;
                break;
            case 2060: // Greater Heal
                _baseHealCache[spellId] = 4000;
                break;
            case 2050: // Heal
                _baseHealCache[spellId] = 3000;
                break;
            default:
                _baseHealCache[spellId] = 1000;
                break;
        }
    }
}

} // namespace Playerbot