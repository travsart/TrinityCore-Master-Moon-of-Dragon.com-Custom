/*
 * Copyright (C) 2024 TrinityCore <https://www.trinitycore.org/>
 */

#include "BotSession.h"
#include "AccountMgr.h"
#include "Log.h"
#include "WorldPacket.h"
#include "Player.h"

namespace Playerbot {

BotSession::BotSession(uint32 bnetAccountId)
    : WorldSession(
        bnetAccountId,                  // Use battlenet account as account ID for now
        "",                            // Empty username (generated by Trinity)
        bnetAccountId,                 // BattleNet account ID
        nullptr,                       // No socket
        SEC_PLAYER,                    // Security level
        EXPANSION_LEVEL_CURRENT,       // Current expansion
        0,                             // Mute time
        "",                            // OS
        Minutes(0),                    // Timezone
        0,                             // Build
        ClientBuild::VariantId{},      // Client build variant
        LOCALE_enUS,                   // Locale
        0,                             // Recruiter
        false),                        // Is recruiter
    _bnetAccountId(bnetAccountId),
    _simulatedLatency(50)
{
    printf("=== PLAYERBOT DEBUG: BotSession constructor for account %u (simplified version) ===\n", bnetAccountId);
    fflush(stdout);

    // Validate account IDs
    if (GetAccountId() == 0) {
        printf("=== PLAYERBOT DEBUG: BotSession creation failed - invalid account ID ===\n");
        fflush(stdout);
        return;
    }

    printf("=== PLAYERBOT DEBUG: BotSession created successfully - BNet ID %u, Legacy ID %u ===\n",
           _bnetAccountId, GetAccountId());
    fflush(stdout);
}

BotSession::~BotSession()
{
    printf("=== PLAYERBOT DEBUG: BotSession destructor for account %u ===\n", GetAccountId());
    fflush(stdout);

    // Clean up AI if present
    if (_ai) {
        delete _ai;
        _ai = nullptr;
    }

    printf("=== PLAYERBOT DEBUG: BotSession destructor completed ===\n");
    fflush(stdout);
}

void BotSession::SendPacket(WorldPacket const* packet, bool forced)
{
    if (!packet) return;

    // Simple packet handling - just store in outgoing queue
    std::lock_guard<std::mutex> lock(_packetMutex);

    // Create a copy of the packet
    auto packetCopy = std::make_unique<WorldPacket>(*packet);
    _outgoingPackets.push(std::move(packetCopy));
}

void BotSession::QueuePacket(WorldPacket* packet)
{
    if (!packet) return;

    // Simple packet handling - just store in incoming queue
    std::lock_guard<std::mutex> lock(_packetMutex);

    // Create a copy of the packet
    auto packetCopy = std::make_unique<WorldPacket>(*packet);
    _incomingPackets.push(std::move(packetCopy));
}

bool BotSession::Update(uint32 diff, PacketFilter& updater)
{
    if (!_active.load()) {
        return false;
    }

    // Process bot packets
    ProcessBotPackets();

    // Call parent Update for Trinity integration
    bool parentResult = WorldSession::Update(diff, updater);

    // Update AI if available
    if (_ai && GetPlayer()) {
        // _ai->Update(diff); // Comment out until AI is implemented
    }

    return parentResult;
}

void BotSession::ProcessBotPackets()
{
    std::lock_guard<std::mutex> lock(_packetMutex);

    // Process a few incoming packets
    int processed = 0;
    while (!_incomingPackets.empty() && processed < 10) {
        auto packet = std::move(_incomingPackets.front());
        _incomingPackets.pop();

        try {
            // Process packet through WorldSession's standard queue system
            WorldSession::QueuePacket(packet.get());
            processed++;
        }
        catch (std::exception const& e) {
            printf("=== PLAYERBOT DEBUG: Exception processing packet: %s ===\n", e.what());
            fflush(stdout);
        }
    }

    // Clear some outgoing packets (simulate processing)
    int cleared = 0;
    while (!_outgoingPackets.empty() && cleared < 10) {
        _outgoingPackets.pop();
        cleared++;
    }
}

} // namespace Playerbot