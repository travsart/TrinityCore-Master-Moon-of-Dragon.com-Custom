/*
 * Copyright (C) 2024 TrinityCore <https://www.trinitycore.org/>
 */

#include "BotSession.h"
#include "AccountMgr.h"
#include "Log.h"
#include "WorldPacket.h"
#include "Player.h"
#include "DatabaseEnv.h"
#include "QueryHolder.h"
#include "QueryCallback.h"
#include "CharacterPackets.h"
#include "CharacterDatabase.h"
#include "Database/PlayerbotCharacterDBInterface.h"
#include "World.h"
#include "Map.h"
#include "MapManager.h"
#include "AI/BotAI.h"
#include <condition_variable>
#include <unordered_set>

// Simplified LoginQueryHolder for bot sessions - no bloated prepared statement spam
class BotLoginQueryHolder : public CharacterDatabaseQueryHolder
{
private:
    uint32 m_accountId;
    ObjectGuid m_guid;
public:
    BotLoginQueryHolder(uint32 accountId, ObjectGuid guid)
        : m_accountId(accountId), m_guid(guid) { }
    ObjectGuid GetGuid() const { return m_guid; }
    uint32 GetAccountId() const { return m_accountId; }

    bool Initialize()
    {
        // Simplified initialization - only load basic character data to avoid corruption
        SetSize(1);

        ObjectGuid::LowType lowGuid = m_guid.GetCounter();

        // Only prepare one essential query to avoid prepared statement 358 corruption
        // Use safe validation to prevent prepared statement assertion failures
        if (CHAR_SEL_CHARACTER >= MAX_CHARACTERDATABASE_STATEMENTS) {
            TC_LOG_ERROR("module.playerbot", "BotLoginQueryHolder: Invalid CHAR_SEL_CHARACTER index {} >= {}",
                        static_cast<uint32>(CHAR_SEL_CHARACTER), MAX_CHARACTERDATABASE_STATEMENTS);
            return false;
        }

        // Use PlayerbotCharacterDBInterface for safe statement access
        CharacterDatabasePreparedStatement* stmt = sPlayerbotCharDB->GetPreparedStatement(CHAR_SEL_CHARACTER);
        if (!stmt) {
            TC_LOG_ERROR("module.playerbot", "BotLoginQueryHolder: Failed to get CHAR_SEL_CHARACTER (index: {})",
                        static_cast<uint32>(CHAR_SEL_CHARACTER));
            return false;
        }
        stmt->setUInt64(0, lowGuid);
        SetPreparedQuery(0, stmt);

        return true;
    }
};

namespace Playerbot {

BotSession::BotSession(uint32 bnetAccountId)
    : WorldSession(
        bnetAccountId,                  // Use battlenet account as account ID for now
        "",                            // Empty username (generated by Trinity)
        bnetAccountId,                 // BattleNet account ID
        nullptr,                       // No socket
        SEC_PLAYER,                    // Security level
        EXPANSION_LEVEL_CURRENT,       // Current expansion
        0,                             // Mute time
        "",                            // OS
        Minutes(0),                    // Timezone
        0,                             // Build
        ClientBuild::VariantId{},      // Client build variant
        LOCALE_enUS,                   // Locale
        0,                             // Recruiter
        false),                        // Is recruiter
    _bnetAccountId(bnetAccountId),
    _simulatedLatency(50)
{
    // Validate account IDs
    if (GetAccountId() == 0) {
        return;
    }
}

BotSession::~BotSession()
{
    // Clean up AI if present
    if (_ai) {
        delete _ai;
        _ai = nullptr;
    }
}

CharacterDatabasePreparedStatement* BotSession::GetSafePreparedStatement(CharacterDatabaseStatements statementId, const char* statementName)
{
    // CRITICAL FIX: Add statement index validation before accessing to prevent assertion failure
    if (statementId >= MAX_CHARACTERDATABASE_STATEMENTS) {
        TC_LOG_ERROR("module.playerbot", "BotSession::GetSafePreparedStatement: Invalid statement index {} >= {} for {}",
                     static_cast<uint32>(statementId), MAX_CHARACTERDATABASE_STATEMENTS, statementName);
        return nullptr;
    }

    // Use PlayerbotCharacterDBInterface for safe statement access with automatic routing
    TC_LOG_DEBUG("module.playerbot.session",
        "Accessing statement {} ({}) through PlayerbotCharacterDBInterface",
        static_cast<uint32>(statementId), statementName);

    CharacterDatabasePreparedStatement* stmt = sPlayerbotCharDB->GetPreparedStatement(statementId);
    if (!stmt) {
        TC_LOG_ERROR("module.playerbot", "BotSession::GetSafePreparedStatement: Failed to get prepared statement {} (index: {})",
                     statementName, static_cast<uint32>(statementId));
        return nullptr;
    }
    return stmt;
}

void BotSession::SendPacket(WorldPacket const* packet, bool forced)
{
    if (!packet) return;

    // Simple packet handling - just store in outgoing queue
    std::lock_guard<std::mutex> lock(_packetMutex);

    // Create a copy of the packet
    auto packetCopy = std::make_unique<WorldPacket>(*packet);
    _outgoingPackets.push(std::move(packetCopy));
}

void BotSession::QueuePacket(WorldPacket* packet)
{
    if (!packet) return;

    // Simple packet handling - just store in incoming queue
    std::lock_guard<std::mutex> lock(_packetMutex);

    // Create a copy of the packet
    auto packetCopy = std::make_unique<WorldPacket>(*packet);
    _incomingPackets.push(std::move(packetCopy));
}

bool BotSession::Update(uint32 diff, PacketFilter& updater)
{
    if (!_active.load()) {
        return false;
    }

    // Process bot packets
    ProcessBotPackets();

    // Call parent Update for Trinity integration
    bool parentResult = WorldSession::Update(diff, updater);

    // Update AI if available
    if (_ai && GetPlayer()) {
        _ai->Update(diff); // BotAI takes control and updates bot behavior
    }

    return parentResult;
}

void BotSession::ProcessBotPackets()
{
    // Use batch processing with larger batch sizes for better performance under load
    constexpr size_t BATCH_SIZE = 50; // Increased from 10 to reduce overhead

    // Batch process packets outside lock to minimize critical sections
    std::vector<std::unique_ptr<WorldPacket>> incomingBatch;
    incomingBatch.reserve(BATCH_SIZE);

    // Extract batch of incoming packets under lock
    {
        std::lock_guard<std::mutex> lock(_packetMutex);

        // Reserve space and extract up to BATCH_SIZE packets
        size_t batchCount = std::min(_incomingPackets.size(), BATCH_SIZE);
        for (size_t i = 0; i < batchCount; ++i) {
            incomingBatch.emplace_back(std::move(_incomingPackets.front()));
            _incomingPackets.pop();
        }

        // Clear outgoing packets (simulate processing) - also batched
        size_t clearCount = std::min(_outgoingPackets.size(), BATCH_SIZE);
        for (size_t i = 0; i < clearCount; ++i) {
            _outgoingPackets.pop();
        }
    }

    // Process the extracted batch outside of lock for better concurrency
    for (auto& packet : incomingBatch) {
        try {
            // Process packet through WorldSession's standard queue system
            WorldSession::QueuePacket(packet.get());
        }
        catch (std::exception const& e) {
            // Log exception through ModuleLogManager
        }
    }
}

bool BotSession::LoginCharacter(ObjectGuid characterGuid)
{
    // Validate inputs
    if (characterGuid.IsEmpty())
    {
        return false;
    }

    if (GetAccountId() == 0)
    {
        return false;
    }

    try
    {
        // Create player and load directly from database (use smart pointer for safety)
        std::unique_ptr<Player> newPlayer = std::make_unique<Player>(this);
        if (!newPlayer)
        {
            return false;
        }

        // CRITICAL FIX: Use async pattern for scalability - avoid blocking main thread
        // For synchronous login, we'll use the existing approach but note this should be async for 5000+ bots
        // The StartAsyncLogin method provides the proper async implementation for high scalability

        // Use prepared statement for security - avoid SQL injection vulnerabilities
        CharacterDatabasePreparedStatement* stmt = GetSafePreparedStatement(CHAR_SEL_CHARACTER, "CHAR_SEL_CHARACTER");
        if (!stmt) {
            return false;
        }
        stmt->setUInt64(0, characterGuid.GetCounter());

        // Use PlayerbotCharacterDBInterface for safe execution with automatic routing
        PreparedQueryResult accountResult = sPlayerbotCharDB->ExecuteSync(stmt);

        if (!accountResult)
        {
            // unique_ptr automatically cleans up newPlayer
            return false;
        }

        Field* accountFields = accountResult->Fetch();
        uint32 characterAccountId = accountFields[0].GetUInt32(); // Account is the only field returned

        // Create LoginQueryHolder with character's REAL account ID (this is the key fix!)
        auto botHolder = std::make_shared<BotLoginQueryHolder>(characterAccountId, characterGuid);
        if (!botHolder->Initialize())
        {
            // unique_ptr automatically cleans up newPlayer
            return false;
        }

        // Load character data using CORRECT account ID
        bool loadResult = newPlayer->LoadFromDB(characterGuid, *botHolder);

        if (!loadResult)
        {
            // unique_ptr automatically cleans up newPlayer
            return false;
        }

        // Set the player for this session (transfer ownership from unique_ptr to session)
        SetPlayer(newPlayer.release());

        // Set character as online
        CharacterDatabasePreparedStatement* onlineStmt = GetSafePreparedStatement(CHAR_UPD_CHAR_ONLINE, "CHAR_UPD_CHAR_ONLINE");
        if (!onlineStmt) {
            return false;
        }
        onlineStmt->setUInt32(0, 1);
        onlineStmt->setUInt64(1, characterGuid.GetCounter());
        sPlayerbotCharDB->ExecuteAsync(onlineStmt);

        // Create and assign BotAI to take control of the character
        auto botAI = BotAIFactory::instance()->CreateAI(GetPlayer());
        if (botAI)
        {
            SetAI(botAI.release()); // Transfer ownership to BotSession
        }

        return true;
    }
    catch (std::exception const& e)
    {
        return false;
    }
    catch (...)
    {
        return false;
    }
}

void BotSession::StartAsyncLogin(ObjectGuid characterGuid)
{
    // Check if async login already in progress (thread-safe)
    {
        std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
        if (_asyncLogin.inProgress)
        {
            return;
        }
        // Set async login state under lock
        _asyncLogin.characterGuid = characterGuid;
        _asyncLogin.inProgress = true;
        _asyncLogin.startTime = std::chrono::steady_clock::now();
        _asyncLogin.player = nullptr;
    }

    // Validate inputs
    if (characterGuid.IsEmpty())
    {
        return;
    }

    try
    {
        // Database connection is handled by TrinityCore's connection pool

        // ASYNC PHASE 1: Get character's account ID asynchronously using prepared statement for security
        TC_LOG_DEBUG("module.playerbot", "BotSession::StartAsyncLogin: Using prepared statement CHAR_SEL_CHARACTER (index: {})", CHAR_SEL_CHARACTER);
        CharacterDatabasePreparedStatement* accountStmt = GetSafePreparedStatement(CHAR_SEL_CHARACTER, "CHAR_SEL_CHARACTER");
        if (!accountStmt) {
            {
                std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
                _asyncLogin.inProgress = false;
            }
            return;
        }
        accountStmt->setUInt64(0, characterGuid.GetCounter());

        // CRITICAL FIX: Use proper async callback pattern to prevent prepared statement corruption
        // This fixes the assertion failure in MySQLConnection::GetPreparedStatement(358)
        auto callback = [this, characterGuid](PreparedQueryResult accountResult) {
            if (!accountResult)
            {
                {
                    std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
                    _asyncLogin.inProgress = false;
                }
                return;
            }

            Field* accountFields = accountResult->Fetch();
            uint32 characterAccountId = accountFields[0].GetUInt32(); // account is field 0 when selecting only account

            // ASYNC PHASE 2: Create player and start async LoadFromDB (using smart pointer for safety)
            std::unique_ptr<Player> newPlayer = std::make_unique<Player>(this);
            if (!newPlayer)
            {
                _asyncLogin.inProgress = false;
                return;
            }

            // Create LoginQueryHolder with character's REAL account ID
            auto botHolder = std::make_shared<BotLoginQueryHolder>(characterAccountId, characterGuid);
            if (!botHolder->Initialize())
            {
                // unique_ptr automatically cleans up newPlayer
                {
                    std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
                    _asyncLogin.inProgress = false;
                }
                return;
            }

            // Start async LoadFromDB operation using TrinityCore's query holder pattern

            // CRITICAL FIX: Simplified async pattern to prevent database connection corruption
            // Avoid complex query holder pattern that causes prepared statement array corruption
            Player* playerPtr = newPlayer.release();

            // Use direct synchronous load to prevent connection pool corruption
            // This is safer than the complex async pattern that was causing statement 358 issues
            bool loadResult = false;
            try {
                loadResult = playerPtr->LoadFromDB(characterGuid, *botHolder);
            } catch (std::exception const& e) {
                TC_LOG_ERROR("module.playerbot", "BotSession::StartAsyncLogin: LoadFromDB exception: {}", e.what());
                loadResult = false;
            }

            if (loadResult) {
                {
                    std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
                    _asyncLogin.player = playerPtr;
                }
                CompleteAsyncLogin(playerPtr, characterGuid);
            } else {
                // Clean up player on failure
                delete playerPtr;
                {
                    std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
                    _asyncLogin.inProgress = false;
                }
            }
        };

        // Use PlayerbotCharacterDBInterface for safe async execution with automatic sync/async routing
        TC_LOG_INFO("module.playerbot.session",
            "About to execute AsyncQuery for statement on playerbot_characters database through PlayerbotCharacterDBInterface");
        sPlayerbotCharDB->ExecuteAsync(accountStmt, std::move(callback));

    }
    catch (std::exception const& e)
    {
        {
            std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
            _asyncLogin.inProgress = false;
        }
    }
    catch (...)
    {
        {
            std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
            _asyncLogin.inProgress = false;
        }
    }
}

void BotSession::CompleteAsyncLogin(Player* player, ObjectGuid characterGuid)
{
    // Thread-safe check of async login state
    {
        std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
        if (!player || !_asyncLogin.inProgress)
        {
            return;
        }
    }

    try
    {
        // Calculate async login time for performance monitoring (thread-safe access)
        auto endTime = std::chrono::steady_clock::now();
        std::chrono::milliseconds duration;
        {
            std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
            duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - _asyncLogin.startTime);
        }

        // Set the player for this session
        SetPlayer(player);

        // Set character as online in database
        CharacterDatabasePreparedStatement* onlineStmt = GetSafePreparedStatement(CHAR_UPD_CHAR_ONLINE, "CHAR_UPD_CHAR_ONLINE");
        if (!onlineStmt) {
            return;
        }
        onlineStmt->setUInt32(0, 1);
        onlineStmt->setUInt64(1, characterGuid.GetCounter());
        sPlayerbotCharDB->ExecuteAsync(onlineStmt);

        // Create and assign BotAI for character control
        auto botAI = BotAIFactory::instance()->CreateAI(player);
        if (botAI)
        {
            SetAI(botAI.release()); // Transfer ownership to BotSession
        }

        // Clear async login state (thread-safe)
        {
            std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
            _asyncLogin.inProgress = false;
            _asyncLogin.player = nullptr;
            _asyncLogin.characterGuid = ObjectGuid::Empty;
        }

    }
    catch (std::exception const& e)
    {
        {
            std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
            _asyncLogin.inProgress = false;
        }
    }
    catch (...)
    {
        {
            std::lock_guard<std::mutex> lock(_asyncLogin.mutex);
            _asyncLogin.inProgress = false;
        }
    }
}

} // namespace Playerbot